#!/usr/bin/gosh
(use srfi-1)
(use util.combinations)
(use gauche.process)

(define (main args)
    (if (not (= (length args) 3))
        (begin
         (print "Usage: " *program-name* " problem answer")
         0)
        (let ((csp (cadr args)))
          (case (read-answer (caddr args))
            ((UNSAT) (print "Can not validate: UNSAT.") 0)
            ((SAT)
             (let ((with-csp (if (#/\.xml$/ csp)
                                 (cut with-input-from-process
                                      `("./xml2csp" ,csp) <>)
                                 (cut with-input-from-file csp <>))))
               (with-csp
                   (cut port-for-each
                        (lambda (exp)
                          (unless (eval exp (interaction-environment))
                            (print "Error: " exp " is violated.")))
                        read)))
             0)
            (else (print "Invalid answer."))))))

(define (read-answer ans)
    (let ((*RESULT* #f))
      (with-input-from-file ans
        (cut port-for-each
             (lambda (line)
               (rxmatch-cond
                (test (equal? "s UNSATISFIABLE" line)
                      (set! *RESULT* 'UNSAT))
                (test (equal? "s SATISFIABLE" line)
                      (set! *RESULT* 'SAT))
                ((rxmatch #/^a ([^\s]+)\s+([^\s]+)$/ line)
                 (#f var val)
                 (eval `(define ,(string->symbol var)
                            ,(if (#/^\d+$/ val)
                                 (string->number val)
                                 (eval (string->symbol val)
                                       (interaction-environment))))
                       (interaction-environment)))))
             read-line))
      *RESULT*))

(define-macro (domain name lb ub)
    `(define ,name ,(if (null? ub)
                        lb
                        `((,lb ,ub)))))

(define-macro (int var lb :optional ub)
    (cond ((integer? ub)
           `(and (<= ,lb ,var) (<= ,var ,ub)))
          ((integer? lb) `(= ,var ,lb))
          (else `(letrec
                  ((loop (lambda (lst)
                           (if (null? lst)
                               #f
                               (let ((hd (car lst)))
                                 (or (if (integer? hd)
                                         (= ,var hd)
                                         (and (<= (car hd) ,var)
                                              (<= ,var (cadr hd))))
                                     (loop (cdr lst))))))))
                  (loop (quote ,lb))))))

(define (bool p) #t)

(define neg -)
(define add +)
(define sub -)
(define mul *)
(define div quotient)
(define / quotient)
(define mod modulo)
(define %   modulo)
;; (define pow xxx)

(define-macro (relation name arity relbody)
    (let* ((rel (car relbody))
           (args (map gensym (iota arity)))
           (pts (cdr relbody))
           (sup `(or ,@(map (lambda (pt)
                              `(and ,@(map (lambda (p) `(apply = ,p))
                                           (zip args pt))))
                            pts))))
      `(define (,name ,@args)
           (if (= rel 'support)
               sup
               `(not ,sup)))))

(define-macro (predicate args predbody)
    `(define ,args ,predbody))

(define ! not)
(define && and)
(define || or)
(define (imp lhs rhs) (or (not lhs) rhs))
(define => imp)
(define (xor p q)
    (or (and p (not q))
        (and (not p) q)))
(define (iff lhs rhs)
    (and (=> lhs rhs)
         (=> rhs lhs)))
(define true #t)
(define false #f)
(define eq =)
(define (ne x y) (not (= x y)))
(define le <=)
(define lt <)
(define ge >=)
(define gt >)

(define (alldifferent term . terms)
    (if (list? term)
        (apply alldifferent term)
        (let ((allterms (cons term terms)))
          (fold (lambda (acc x) (and acc (apply ne x))) #t
                (combinations allterms 2)))))
(define (weightedsum pairs op term)
    (op (fold + 0 (map (lambda (x) (apply * x)) pairs)) term))
(define (cumulative task limit)
    )
(define (element idx terms value)
    (= (values-ref terms (- idx 1)) value))
(define (disjunctive tasks)
    )
(define (lex_less vec1 vec2)
    (apply and (map (lambda (x) (apply < x)) (zip vec1 vec2))))
(define (lex_lesseq vec1 vec2)
    (if (null? vec1)
        #t
        (apply and (map (lambda (x) (apply <= x)) (zip vec1 vec2)))))
(define (nvalue term terms)
    (letrec ((cnt (lambda (c v lst)
                    (if (null? lst)
                        c
                        (if (< v (car lst))
                            (cnt (+ c 1) (car lst) (cdr lst))
                            (cnt c v (cdr lst)))))))
            (let ((sorted (sort terms)))
              (cnt 1 (car sorted) (cdr sorted)))))
(define (global_cardinality terms cards)
    )
(define (global_cardinality_with_costs terms cards tables costs)
    )
(define (count value terms op term)
    (op (fold (lambda (acc x)
                (if (= x value)
                    (+ 1 acc) acc)) 0 terms)
        term))

(define (objective goal name)
    #t)
